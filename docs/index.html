
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <title>README Â· GitBook</title>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.1.1">
        
        
        
    
    <link rel="stylesheet" href="gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-page-toc-optional/page-toc.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="gitbook/images/favicon.ico" type="image/x-icon">

    
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter active" data-level="1.1" data-path="./">
            
                <a href="./">
            
                    
                    README
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href="." >README</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="vsm-dictionary-bioportal">vsm-dictionary-bioportal</h1>
<h2 id="summary">Summary</h2>
<p><code>vsm-dictionary-bioportal</code> is an implementation 
of the &apos;VsmDictionary&apos; parent-class/interface (from the package
<a href="https://github.com/vsmjs/vsm-dictionary" target="_blank"><code>vsm-dictionary</code></a>), that
communicates with <a href="https://bioportal.bioontology.org/" target="_blank">BioPortal&apos;s</a> 
REST API and translates the provided terms+IDs into a VSM-specific format.</p>
<h2 id="example-use">Example use</h2>
<p>You first need to have a BioPortal account to use this dictionary. Once you 
have an account, you will be given an API key to authorise your access to 
the provided REST API&apos;s resources. Then, you can create a <code>test.js</code> file and
include this code for example:</p>
<pre><code class="lang-javascript"><span class="hljs-keyword">const</span> DictionaryBioPortal = <span class="hljs-built_in">require</span>(<span class="hljs-string">&apos;./DictionaryBioPortal&apos;</span>);
<span class="hljs-keyword">const</span> apiKeyString = <span class="hljs-string">&apos;a-valid-API-key-string&apos;</span>;
<span class="hljs-keyword">const</span> dict = <span class="hljs-keyword">new</span> DictionaryBioPortal({apiKey: apiKeyString});

dict.getEntryMatchesForString(<span class="hljs-string">&apos;melanoma&apos;</span>,
  { filter: { dictID : [
        <span class="hljs-string">&apos;http://data.bioontology.org/ontologies/RH-MESH&apos;</span>,
        <span class="hljs-string">&apos;http://data.bioontology.org/ontologies/MCCL&apos;</span>,
        <span class="hljs-string">&apos;http://data.bioontology.org/ontologies/MEDDRA&apos;</span>
      ]},
    sort: { dictID : [<span class="hljs-string">&apos;http://data.bioontology.org/ontologies/RH-MESH&apos;</span>] },
    z: <span class="hljs-literal">true</span>,
    page: <span class="hljs-number">1</span>,
    perPage: <span class="hljs-number">10</span>
  }, (err, res) =&gt; {
    <span class="hljs-keyword">if</span> (err) 
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(err, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>));
    <span class="hljs-keyword">else</span>
      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(res, <span class="hljs-literal">null</span>, <span class="hljs-number">4</span>));
  }
);
</code></pre>
<p>Then, run <code>node test.js</code></p>
<h2 id="tests">Tests</h2>
<p>Run <code>npm test</code>, which runs the source code tests with Mocha.<br>If you want to live test the BioPortal API and the main functions provided
by DictionaryBioPortal, go to the <code>test</code> directory and run:</p>
<pre><code>node getDictInfos.test.js
node getEntries.test.js
node getEntryMatchesForString.test.js
</code></pre><h2 id="browser-demo">Browser Demo</h2>
<p>Run <code>npm run demo</code> to start the interactive demo.
The demo currently supports only the <code>getMatchesForString()</code> function.
This command automatically opens a browser page with 6 input-fields to
search on BioPortal ontology data. The 6 inputs fields represent:</p>
<ol>
<li>The string to search results for</li>
<li>The dictionary abbreviations (e.g. GO,MCCL), comma separated, that 
will be used as arguments for filtering the results</li>
<li>The preferred dictionary abbreviations, comma separated, that 
will be used as arguments for sorting the results</li>
<li>The z-object&apos;s properties to be kept in the result (if left empty, 
all properties will be shown)</li>
<li>The page number - note that only for <code>page=1</code> there is a possibility
of sorting the results taking into account the preferred dictionaries</li>
<li>The page size returned, which is the maximum number of returned 
terms/results in the demo.</li>
</ol>
<p>The demo works by making a Webpack dev-server bundle all source code 
and serve it to the browser.</p>
<h2 id="build-configuration--demo">&apos;Build&apos; configuration &amp; demo</h2>
<p>To use a VsmDictionary in Node.js, one can simply run <code>npm install</code> and then
use <code>require()</code>. But it is also convenient to have a version of the code that
can just be loaded via a &lt;script&gt;-tag in the browser.</p>
<p>Therefore, we included <code>webpack.config.js</code> (note: the one in the root folder, 
<em>not</em> the one in the &apos;demo&apos; folder), which is a Webpack configuration file for 
generating such a browser-ready package.</p>
<p>By running <code>npm build</code>, the built file will appear in a &apos;dist&apos; subfolder. 
A demo-use of this file can then be seen by opening <code>demo-build.html</code> 
(in the &apos;demo&apos; folder). (It includes a 
<code>&lt;script src=&quot;../dist/vsm-dictionary-bioportal.min.js&quot;&gt;&lt;/script&gt;</code> tag). 
So after the build step, <code>demo-build.html</code> does not need Webpack to run.</p>
<h2 id="specification">Specification</h2>
<p>Like all VsmDictionary subclass implementations, this package follows
the parent class
<a href="https://github.com/vsmjs/vsm-dictionary/blob/master/Dictionary.spec.md" target="_blank">specification</a>.
In the next sections we will explain the mapping between BioPortal&apos;s API 
terms (as specified in the <a href="http://data.bioontology.org/documentation" target="_blank">API documentation</a>)
and the corresponding VSM objects. First, some info about the API itself:</p>
<p>Most of the queries we launch against BioPortal use the <em>search endpoint</em>:
<code>/search?q={search query}</code>, along with different parameters. One of the 
most important parameters is the filtering on the ontologies&apos; abbreviation
names: <code>ontologies={ontologyAbbrev1,ontologyAbbrev2,ontologyAbbrev3}</code>.</p>
<p>The returned terms have fields which are matched against the <em>search query</em> 
(q parameter). The fields are searched based on the following order of 
<strong>match rank priority:</strong></p>
<ul>
<li>id</li>
<li>prefLabelExact (match on the full pref label) </li>
<li>prefLabel (match on partial pref label)</li>
<li>synonymExact (match on the full synonym(s))</li>
<li>synonym (match on the partial synonym(s))</li>
<li>notation (last fragment of id)</li>
<li>cui (for UMLS ontologies)</li>
<li>semantic_types</li>
</ul>
<p>If the URL has the <code>ontologies</code> parameter, then when you get results that have 
the same field from the list above (e.g. same id), these are ordered according 
to an internal (BioPortal) <strong>ontology ranking</strong>, which is updated every week. 
At the time of writing these lines, the latest ranking was stored 
<a href="https://gist.github.com/mdorf/cea96433cf4bf7dd94d109c8e06e29c0" target="_blank">here</a> for 
reference. </p>
<h3 id="map-bioportal-to-dictinfo-vsm-object">Map BioPortal to DictInfo VSM object</h3>
<p>This specification relates to the function:<br> <code>getDictInfos(options, cb)</code></p>
<p>An example of a URL string that is being built and send to BioPortal is:</p>
<pre><code>http://data.bioontology.org/ontologies/GO?display_context=false
</code></pre><p>If <code>options.filter.id</code> is empty or not properly defined, then we query all of
BioPortal&apos;s ontologies with:</p>
<pre><code>http://data.bioontology.org/ontologies/?display_context=false
</code></pre><p>The <code>options.page</code> and <code>options.perPage</code> are used to trim the number of the
results. If these options are not properly defined, then the default values 
from the BioPortal API are used (<em>1</em> and <em>50</em> respectively).</p>
<p>After sending a query to ask for information about a specific ontology, the 
returned JSON result is mapped to a VSM dictInfo object. The mapping is fully 
detailed in the table below:</p>
<table>
<thead>
<tr>
<th style="text-align:center">BioPortal ontology property</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Required</th>
<th style="text-align:center">VSM dictInfo object property</th>
<th>Notes  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@id</code></td>
<td style="text-align:center">URL</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>id</code></td>
<td>the unique ontology URI</td>
</tr>
<tr>
<td style="text-align:center"><code>acronym</code></td>
<td style="text-align:center">String</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>abbrev</code></td>
<td>the unique ontology acronym</td>
</tr>
<tr>
<td style="text-align:center"><code>name</code></td>
<td style="text-align:center">String</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>name</code></td>
<td>the full name of the ontology</td>
</tr>
</tbody>
</table>
<h3 id="map-bioportal-to-entry-vsm-object">Map BioPortal to Entry VSM object</h3>
<p>This specification relates to the function:<br> <code>getEntries(options, cb)</code></p>
<p>Depending on the <code>options.filter.id</code> and <code>options.filter.dictID</code> properties and
following the vsm-dictionary parent class <a href="https://github.com/vsmjs/vsm-dictionary/blob/master/Dictionary.spec.md" target="_blank">specification</a>,
there can be only be 4 cases of queries that are send to BioPortal:</p>
<ul>
<li>Non proper <code>filter.id</code> and <code>filter.dictID</code> or <code>options.filter</code> is an 
empty object</li>
</ul>
<p>By default we search for all terms in all ontologies in BioPortal:</p>
<pre><code>http://data.bioontology.org/search?ontologies=&amp;ontology_types=ONTOLOGY&amp;pagesize=1&amp;display_context=false
</code></pre><p>Note that because the query above has neither a search string, nor multiple 
ontologies to rank against, the returned results have no deterministic order. </p>
<ul>
<li>Non proper <code>filter.id</code> but proper <code>filter.dictID</code> property</li>
</ul>
<p>We use the following query to get all terms within a set of ontologies:</p>
<pre><code>http://data.bioontology.org/search?ontologies=NCIT,GO&amp;ontology_types=ONTOLOGY&amp;pagesize=1&amp;display_context=false
</code></pre><p>Also here, no sorting is done.</p>
<ul>
<li>Proper <code>filter.id</code> but non proper <code>filter.dictID</code> property</li>
</ul>
<p>We use the following query to find a term by id (without any given ontologies):</p>
<pre><code>http://data.bioontology.org/search?q=http%3A%2F%2Fpurl.obolibrary.org%2Fobo%2FDOID_1909&amp;ontologies=&amp;require_exact_match=true&amp;also_search_obsolete=true&amp;display_context=false
</code></pre><p>Note that in case of querying for specific id(s), we ask also for obsolete terms.</p>
<p>Furthermore, because of multiple ontologies having terms with the same id, we 
sort the results according to the parent class <a href="https://github.com/vsmjs/vsm-dictionary/blob/master/Dictionary.spec.md" target="_blank">specification</a>,
only when the <code>options.getAllResults</code> hack is enabled. We have also implemented 
a workaround that infers the ontology abbreviation name from the id in some 
cases. In the case of multiple entries with the same id, the entry for which we 
can correctly infer their source ontology will be ranked first in the returned
result (otherwise the first in the array of sorted results).</p>
<ul>
<li>Both proper <code>filter.id</code> and <code>filter.dictID</code> properties</li>
</ul>
<p>We use the following query to find a term by id within any of the given 
ontologies:</p>
<pre><code>http://data.bioontology.org/search?q=http%3A%2F%2Fpurl.obolibrary.org%2Fobo%2FDOID_1909&amp;ontologies=BAO,DOID&amp;require_exact_match=true&amp;also_search_obsolete=true&amp;display_context=false
</code></pre><p>Same as the previous case, we sort only when the <code>options.getAllResults</code> hack 
is enabled and the obsolete terms are also retrieved.</p>
<p>So, after sending one query from the 4 categories above to BioPortal, the 
returned JSON result object includes a <code>collection</code> property which has as 
a value, an array of objects. Each object/element of that array is an entry 
which is mapped to a VSM entry object. The mapping is fully detailed in the 
table below:</p>
<table>
<thead>
<tr>
<th style="text-align:center">BioPortal entry&apos;s property</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Required</th>
<th style="text-align:center">VSM entry object property</th>
<th style="text-align:center">Notes  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@id</code></td>
<td style="text-align:center">URL</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>id</code></td>
<td style="text-align:center">the concept-ID</td>
</tr>
<tr>
<td style="text-align:center"><code>links.ontology</code></td>
<td style="text-align:center">URL</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>dictID</code></td>
<td style="text-align:center">the unique identifier of the ontology</td>
</tr>
<tr>
<td style="text-align:center"><code>definition</code></td>
<td style="text-align:center">Array</td>
<td style="text-align:center">NO</td>
<td style="text-align:center"><code>descr</code></td>
<td style="text-align:center">we map the first definition only</td>
</tr>
<tr>
<td style="text-align:center"><code>synonym</code></td>
<td style="text-align:center">Array</td>
<td style="text-align:center">NO</td>
<td style="text-align:center"><code>terms[i].str</code></td>
<td style="text-align:center">we map the whole array, first element of <code>terms</code> array is an object with property <code>str</code> and value the <code>prefLabel</code></td>
</tr>
<tr>
<td style="text-align:center"><code>links.ontology</code></td>
<td style="text-align:center">URL</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>z.dictAbbrev</code></td>
<td style="text-align:center">the unique ontology acronym</td>
</tr>
<tr>
<td style="text-align:center"><code>cui</code></td>
<td style="text-align:center">Array</td>
<td style="text-align:center">NO</td>
<td style="text-align:center"><code>z.cui</code></td>
<td style="text-align:center">Concept Unique Identifier</td>
</tr>
<tr>
<td style="text-align:center"><code>semanticType</code></td>
<td style="text-align:center">Array</td>
<td style="text-align:center">NO</td>
<td style="text-align:center"><code>z.tui</code></td>
<td style="text-align:center">Type Unique Identifier</td>
</tr>
<tr>
<td style="text-align:center"><code>obsolete</code></td>
<td style="text-align:center">Boolean</td>
<td style="text-align:center">NO</td>
<td style="text-align:center"><code>z.obsolete</code></td>
<td style="text-align:center">This z option is returned only when requesting for specific entry id(s)</td>
</tr>
</tbody>
</table>
<h3 id="map-bioportal-to-match-vsm-object">Map BioPortal to Match VSM object</h3>
<p>This specification relates to the function:<br> <code>getEntryMatchesForString(str, options, cb)</code></p>
<p>An example of a URL string that is being built and send to BioPortal is:</p>
<pre><code>http://data.bioontology.org/search?q=melanoma&amp;ontologies=RH-MESH,MCCL&amp;page=1&amp;pagesize=40&amp;display_context=false
</code></pre><p>The parameters are as follows:</p>
<ul>
<li><code>str</code> maps to <code>q=str</code></li>
<li><code>page</code> is the <code>options.page</code> and <code>pagesize</code> is <code>options.perPage</code></li>
<li>The <code>ontologies</code> part of the URL corresponds to the sub-dictionaries from 
where we want to get terms. This parameter is being built according to the 
values of <code>options.filter.dictID</code> and <code>options.sort.dictID</code> as well as the
<a href="https://github.com/vsmjs/vsm-dictionary/blob/master/Dictionary.spec.md" target="_blank">specification</a>
of the vsm-dictionary parent class. Note that there can be cases where 2 URLs
are fired (simultaneously) during a string search to get results for preferred
dictionaries and all the rest for example.</li>
</ul>
<p>All the above are optional URL parameters, meaning that if
for example the <code>options</code> object is empty, then the default BioPortal API 
values will be used instead for <code>page</code> and <code>pagesize</code> (1 and 50 respectively), 
while the search will be done on all ontologies available at BioPortal&apos;s 
repository (the <code>ontologies=</code> part of the URL will be pruned):</p>
<pre><code>http://data.bioontology.org/search?q=melanoma&amp;display_context=false
</code></pre><p>The search string is obligatory though (if you want to get non-empty results :) 
and the <code>display_context=false</code> is always added since it does not provide any
useful data to be mapped to a VSM match object.</p>
<p>After sending such a query, the returned JSON result object includes a 
<code>collection</code> property which has as a value, an array of objects. Each 
object/element of that array is an entry which is mapped to a VSM match 
object. The mapping is fully detailed in the table below:</p>
<table>
<thead>
<tr>
<th style="text-align:center">BioPortal entry&apos;s property</th>
<th style="text-align:center">Type</th>
<th style="text-align:center">Required</th>
<th style="text-align:center">VSM match object property</th>
<th style="text-align:center">Notes  </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>@id</code></td>
<td style="text-align:center">URL</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>id</code></td>
<td style="text-align:center">the concept-ID</td>
</tr>
<tr>
<td style="text-align:center"><code>links.ontology</code></td>
<td style="text-align:center">URL</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>dictID</code></td>
<td style="text-align:center">the unique identifier of the ontology</td>
</tr>
<tr>
<td style="text-align:center"><code>prefLabel</code></td>
<td style="text-align:center">String</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>str</code>,<code>terms[0].str</code></td>
<td style="text-align:center">the string representation of the term</td>
</tr>
<tr>
<td style="text-align:center"><code>definition</code></td>
<td style="text-align:center">Array</td>
<td style="text-align:center">NO</td>
<td style="text-align:center"><code>descr</code></td>
<td style="text-align:center">we map the first definition only</td>
</tr>
<tr>
<td style="text-align:center"><code>synonym</code></td>
<td style="text-align:center">Array</td>
<td style="text-align:center">NO</td>
<td style="text-align:center"><code>terms[i].str</code></td>
<td style="text-align:center">we map the whole array, first element of <code>terms</code> array is an object with property <code>str</code> and value the <code>prefLabel</code></td>
</tr>
<tr>
<td style="text-align:center"><code>links.ontology</code></td>
<td style="text-align:center">URL</td>
<td style="text-align:center"><strong>YES</strong></td>
<td style="text-align:center"><code>z.dictAbbrev</code></td>
<td style="text-align:center">the unique ontology acronym</td>
</tr>
<tr>
<td style="text-align:center"><code>cui</code></td>
<td style="text-align:center">Array</td>
<td style="text-align:center">NO</td>
<td style="text-align:center"><code>z.cui</code></td>
<td style="text-align:center">Concept Unique Identifier</td>
</tr>
<tr>
<td style="text-align:center"><code>semanticType</code></td>
<td style="text-align:center">Array</td>
<td style="text-align:center">NO</td>
<td style="text-align:center"><code>z.tui</code></td>
<td style="text-align:center">Type Unique Identifier</td>
</tr>
</tbody>
</table>
<h2 id="documentation">Documentation</h2>
<p>You can view this <em>README</em> in gitbook format 
<a href="https://vsmjs.github.io/vsm-dictionary-bioportal/" target="_blank">here</a>.</p>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"README","level":"1.1","depth":1,"dir":"ltr"},"config":{"gitbook":"3.1.1","theme":"default","variables":{},"plugins":["page-toc-optional"],"pluginsConfig":{"page-toc-optional":{"position":"before-first","selector":".markdown-section h1, .markdown-section h2, .markdown-section h3, .markdown-section h4","showByDefault":true},"search":{},"position":"top","lunr":{"maxIndexSize":1000000},"showByDefault":true,"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"selector":".markdown-section h1, .markdown-section h2, .markdown-section h3"},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"}},"file":{"path":"README.md","mtime":"2019-03-10T22:55:51.713Z","type":"markdown"},"gitbook":{"version":"3.1.1","time":"2019-03-10T22:56:36.305Z"},"basePath":".","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="gitbook/gitbook.js"></script>
    <script src="gitbook/theme.js"></script>
    
        
        <script src="gitbook/gitbook-plugin-page-toc-optional/anchor-3.1.1.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-page-toc-optional/page-toc.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

